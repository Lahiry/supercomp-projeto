# Heurística Greedy 

O código utilizado para implementar a Heurística Greedy é o seguinte:

```c
#include <map>
#include <vector>
#include <iostream>
#include <algorithm>

using namespace std;

struct movie {
    int start;
    int end;
    int category;
};

bool order(movie a, movie b) {
    if (a.end < b.end) {
        return true;
    } else if (a.end == b.end) {
        return a.start < b.start;
    } else {
        return false;
    }
}

vector<movie> greedy(vector<movie> movies, map<int, int> category_limit) {
    int n = movies.size();
    vector<movie> marathon;
    vector<int> available_times;

    for (int i = 0; i < 24; i++) {
        available_times.push_back(i);
    }

    sort(movies.begin(), movies.end(), order);

    for (int i = 0; i < n; i++) {

        bool can_watch = true;
        
        if (movies[i].start < movies[i].end) {
            for (int j = movies[i].start; j < movies[i].end; j++) {
                if (find(available_times.begin(), available_times.end(), j) == available_times.end()) {
                    can_watch = false;
                } 
            }

            if (can_watch && category_limit[movies[i].category] > 0) {
                category_limit[movies[i].category] -= 1;

                for (int k = movies[i].start; k < movies[i].end; k++) {
                    available_times.erase(remove(available_times.begin(), available_times.end(), k), available_times.end());
                }

                marathon.push_back(movies[i]);
            }
        }
    }

    return marathon;
}

int main() {
    int n, c;
    cin >> n >> c; 
    vector<movie> movies;
    map<int, int> category_limit;

    for (int i = 0; i < c; i++) {
        int limit;
        cin >> limit;
        category_limit[i+1] = limit;
    }

    for (int i = 0; i < n; i++) {
        int start, end, category;
        cin >> start >> end >> category;
        movies.push_back({start, end, category});
    }

    vector<movie> marathon = greedy(movies, category_limit);

    for (auto& movie: marathon) {
        cout << "Start: " << movie.start << " " << "End: " << movie.end << " " << "Category: " << movie.category << endl;
    }

    return 0;
}
```

## Explicação

Primeiramente incluimos as bibliotecas a serem utilizadas e definimos a struct movie, que contem o horário de início, horário final
e categoria do filme.

Na main function, começamos definindo e recebendo as váriaveis n (total de filmes) e c (quantidade de categorias). 
Então definimos um vetor movies que irá conter todos os filmes lidos do input e um dicionário category_limit no qual suas chaves
serão as categorias e os valores os limites de filmes das respectivas categorias. Com isso, são feitos dois for loops que irão
preencher o dicionário category_limit e o vetor movies. Para conter o resultado final do algoritmo é criado um vetor de filmes chamado marathon
que faz uma chamada a função principal greedy, que recebe o vetor movies e o dicionário category_limit.

A função greedy começa inicializando uma variável inteira n, que irá conter o tamanho da lista de movies, o vetor de filmes marathon
que irá conter os filmes selecionados e um vetor de inteiros available_times que irá manter a conta de quais horários estão disponíveis.
Então é feito um for loop de 0 até 23 para inicializar o available_times com todos os horários disponíveis. Depois disso, com a funcão de ordenação
order, realizamos um sort no vetor de filmes pelo horário final e depois pelo horário de início, como especificado no enunciado do projeto. 
Tendo isso feito começamos o loop principal, que começa inicializando uma variável booleana can_watch como true, passa por todos os filmes dentro do vetor de filmes
ordenados movies, checa se o horário de início do filme é menor que o horário final e vê se os horários que o filme ocupa estão disponíveis no vetor available_times.
Caso o filme em análise não esteja disponível nos horários, a flag can_watch é setada como false. Depois disso é feito uma checagem se a variável can_watch permanece
como true e se o limite da categoria do filme atual é maior que zero. Caso isso seja verdade, decrementamos o valor do limite da categoria do filme atual, tiramos os 
horários que ele ocupa do vetor available_times e adicionamos esse filme no vetor de filmes marathon. Após todas as iterações do for loop, é retornado o vetor marathon
como resposta da função greedy.