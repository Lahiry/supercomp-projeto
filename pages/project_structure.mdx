import Bleed from 'nextra-theme-docs/bleed'
import Callout from 'nextra-theme-docs/callout'

# Estrutura do projeto

## Estrutura de pastas

```bash
.
â”œâ”€â”€ CMakeLists.txt
â”œâ”€â”€ bin
â”œâ”€â”€ build
â”œâ”€â”€ include
â”œâ”€â”€ lib
â”‚Â Â  â”œâ”€â”€ CMakeLists.txt
â”‚Â Â  â”œâ”€â”€ greedy
â”‚Â Â  â”‚Â Â  â”œâ”€â”€ greedy.cpp
â”‚Â Â  â”‚Â Â  â””â”€â”€ greedy.hpp
â”‚Â Â  â”œâ”€â”€ random
â”‚Â Â  â”‚Â Â  â”œâ”€â”€ random.cpp
â”‚Â Â  â”‚Â Â  â””â”€â”€ random.hpp
â”‚Â Â  â””â”€â”€ scheduler
â”‚Â Â      â”œâ”€â”€ scheduler.cpp
â”‚Â Â      â””â”€â”€ scheduler.hpp
â”œâ”€â”€ scripts
â”‚Â Â  â”œâ”€â”€ input_generator.bash
â”‚Â Â  â””â”€â”€ output_generator.bash
â”œâ”€â”€ src
â”‚Â Â  â”œâ”€â”€ generator.cpp
â”‚Â Â  â””â”€â”€ main.cpp
â””â”€â”€ valgrind
    â”œâ”€â”€ callgrind_annotate_greedy.txt
    â”œâ”€â”€ callgrind_annotate_random.txt
    â”œâ”€â”€ callgrind.out.greedy
    â”œâ”€â”€ callgrind.out.random
    â””â”€â”€ error_and_leakage_report.txt
```

- O arquÃ­vo `CMakeLists.txt` localizado na raiz contÃ©m as instruÃ§Ãµes de *compilaÃ§Ã£o* do projeto.
- A pasta `bin` conterÃ¡ os arquivos executÃ¡veis gerados pelo comando `make`.
- A pasta `build` conterÃ¡ os arquivos gerados pelo `cmake` (Ã© aqui que rodamos o comando `make`).
- A pasta `include` conterÃ¡ os arquivos de cabeÃ§alho necessÃ¡rios para o projeto.
- A pasta `lib` conterÃ¡ as bibliotecas necessÃ¡rias para o projeto.
    - Para cada biblioteca criada, existe uma pasta com o nome da biblioteca, onde dentro dela existem os arquivos fonte e os arquivos de cabeÃ§alho (`.cpp` e `.hpp`).
- A pasta `scripts` conterÃ¡ os scripts necessÃ¡rios para gerar os inputs e outputs do projeto.
- A pasta `src` conterÃ¡ o arquivo fonte do projeto (`main.cpp`) e o arquivo gerador de inputs (`generator.cpp`).
- A pasta `valgrind` conterÃ¡ os arquivos gerados pelo `valgrind` para anÃ¡lise de *leaks* e *performance*.

## Arquitetura do projeto

<Callout emoji="ğŸ“š" title="ReferÃªncias">
    Este projeto foi realizado utilizando a linguagem de programaÃ§Ã£o C++ com programaÃ§Ã£o orientada a objetos.
</Callout>

- O projeto foi dividido em 3 partes principais:
    - A biblioteca `scheduler` Ã© responsÃ¡vel por ler os inputs e gerar os outputs. Nela estÃ¡ implementada a classe `Scheduler` que Ã© responsÃ¡vel por ler os inputs, realizar checagens se o filme Ã© vÃ¡lido e cabe na agenda, e gerar os outputs.
    - A biblioteca `greedy` Ã© responsÃ¡vel por implementar o algoritmo guloso. Nela estÃ¡ implementada a classe `Greedy` que herda da classe `Scheduler` e implementa o algoritmo guloso.
    - A biblioteca `random` Ã© responsÃ¡vel por implementar o algoritmo aleatÃ³rio. Nela estÃ¡ implementada a classe `Random` que herda da classe `Scheduler` e implementa o algoritmo aleatÃ³rio.

<Callout emoji="âš ï¸" title="warning">
    Para esse projeto, foi decidio que construiria o cÃ³digo utilizando programaÃ§Ã£o com alocaÃ§Ã£o 
    dinÃ¢mica de memÃ³ria, utilizando ponteiros como int *i = new int.
    Ela permite ter mais controle sobre o uso da memÃ³ria e criar estruturas de dados dinÃ¢micas e 
    escalÃ¡veis que podem ser alteradas em tempo de execuÃ§Ã£o.

    Uma das principais vantagens da alocaÃ§Ã£o dinÃ¢mica Ã© a possibilidade de alocar grandes quantidades de 
    memÃ³ria sem esgotar a pilha de chamadas da funÃ§Ã£o. Isso Ã© especialmente Ãºtil quando eu preciso criar 
    uma grande quantidade de variÃ¡veis ou estruturas de dados em um curto perÃ­odo de tempo.

    No entanto, Ã© importante lembrar que a alocaÃ§Ã£o dinÃ¢mica requer mais cuidado e atenÃ§Ã£o por parte do 
    programador, pois Ã© sua responsabilidade gerenciar a memÃ³ria alocada e liberÃ¡-la quando nÃ£o for mais 
    necessÃ¡ria. Se o uso da alocaÃ§Ã£o dinÃ¢mica for feito de maneira incorreta, pode levar a vazamentos de 
    memÃ³ria e erros graves no programa.
</Callout>
<Callout emoji="ğŸ“š" title="ReferÃªncias">
    Para ver os resultados do `valgrind` de erros e vazamentos de memÃ³ria, clique [aqui](results_comparison)
</Callout>

## Passos para executar o projeto
<Callout emoji="ğŸ“">
    Para executar o projeto, Ã© necessÃ¡rio ter o `cmake` instalado, assim como a biblioteca `Boost`.
</Callout>
  - Para macOS, basta executar os seguintes comandos:
  ```bash
  brew install cmake
  brew install boost
  ```
  - Para Linux, basta executar os seguintes comandos: 
  ```bash
  sudo apt install cmake
  sudo apt install libboost-all-dev
  ```

- Para compilar o projeto, basta executar os seguintes comandos:
```bash
mkdir build && cd build
cmake ..
make
```

- Para executar o projeto, basta executar o seguinte comando:
```bash
cd scripts
./input_generator.bash
./output_generator.bash
```

- Para executar o `generator.cpp` isoladamente, basta executar o seguinte comando:
```bash
./bin/generator <file_name>.<file_extension>
```