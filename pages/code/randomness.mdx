import Bleed from 'nextra-theme-docs/bleed'
import Callout from 'nextra-theme-docs/callout'

# Aleatoriza√ß√£o


## class Random

Abaixo temos o arquivo `random.hpp` que contem a classe `Random` e herda da classe `Scheduler`:
```cpp
#pragma once

#include "scheduler/scheduler.hpp"

class Random : public Scheduler
{
public:
    void scheduleMovies();
    void generateOutput();
};
```

Este arquivo conta com todas as fun√ß√µes-membro da super-classe `Scheduler` e tamb√©m com as seguintes fun√ß√µes-membro:

- `void scheduleMovies()`: fun√ß√£o que gera a agenda de filmes com a heur√≠stica gulosa misturada com aleatoriza√ß√£o.
- `void generateOutput()`: fun√ß√£o que gera o arquivo de sa√≠da com o resultado da heur√≠stica gulosa misturada com aleatoriza√ß√£o.

A fun√ß√£o `void scheduleMovies()` nesse caso √© a fun√ß√£o que gera a agenda de filmes com a heur√≠stica gulosa misturada com aleatoriza√ß√£o. 

Para implemant√°-la, primeiramente foi criado um unoredered_set que ir√° conter os indices visitados durante o loop. Ap√≥s isso iniciamos um while loop
para incrementar um contador i, que vai de 0 at√© a quantidade de filmes que temos. A condi√ß√£o de quebra do loop √© a agenda de filmes
estar completa e o contador de filmes ultrapassar a quantidade maxima de filmes possiveis de serem vistos em um dia. Feitas as checagens
sorteamos um n√∫mero aleat√≥rio de 0 a 99, onde se o n√∫mero gerado for menor do que 75, iremos aplicar a Heur√≠stica Greedy para escolher o filme.
Caso contr√°rio, iremos sortear um ind√≠ce aleat√≥rio dentre os poss√≠veis para escolha de filme e entramos em um loop cuja condi√ß√£o de quebra √© 
caso o √≠ndice sorteado j√° tenha sido visitado e se a agenda j√° estiver cheia. Caso isso n√£o ocorra fazemos uma checagem se o filme correspondente
ao √≠ndice gerado √© v√°lido ou n√£o. Se o filme for v√°lido, o adicionamos a nossa agenda e atualizamos o nosso unordered_set de indices visitados
com o novo √≠ndice do filme adicionado, caso contr√°rio, atualizamos o nosso unordered_set de indices visitados
com o o que sorteamos e depois geramos um novo √≠ndice aleat√≥rio e repetimos o processo at√© que o filme seja v√°lido e at√© que
a agenda esteja cheia.

<Callout emoji="üëÄ" title="Observa√ß√£o">
    Confira o c√≥digo completo abaixo:
</Callout>

```cpp
#include "random.hpp"
#include <cstdlib>
#include <ctime>
#include <algorithm>
#include <unordered_set>
#include <vector>
#include <iostream>
#include <chrono>


void Random::scheduleMovies()
{
    std::srand(std::time(nullptr));

    std::unordered_set<int> *visitedIndexes = new std::unordered_set<int>();
    int *i = new int(-1);
    int *choosenIndex = new int;

    while (++*i < *this->movies && this->agendaBitset->count() < 24)
    {
        if (std::rand() % 100 < 75)
        {
            if (this->movieIsValid(this->moviesList[*i]) && visitedIndexes->count(*i) == 0)
            {
                this->addMovieToAgenda(this->moviesList[*i]);
                visitedIndexes->insert(*i);
            }
        }
        else
        {
            *choosenIndex = std::rand() % *this->movies;
            do
            {
                if (this->movieIsValid(this->moviesList[*choosenIndex]))
                {
                    this->addMovieToAgenda(this->moviesList[*choosenIndex]);
                    visitedIndexes->insert(*choosenIndex);
                    break;
                }
                *choosenIndex = std::rand() % *this->movies;
                visitedIndexes->insert(*choosenIndex);
            } while (visitedIndexes->count(*choosenIndex) == 0 && this->agendaBitset->count() > 0);
        }
    }

    delete choosenIndex;
    delete visitedIndexes;
    delete i;
}

void Random::generateOutput()
{
    this->readMoviesCatalog();
    auto start = std::chrono::high_resolution_clock::now();
    this->scheduleMovies();
    auto finish = std::chrono::high_resolution_clock::now();
    std::chrono::duration<double> elapsed = finish - start;
    std::cout << 1 << ' ' << *this->movies << ' ' << *this->categories << ' ' << *this->acceptedMoviesCount << ' ' << elapsed.count() << '\n';
}
```